
## MVP为什么比MVC更合适？
### MVC有什么问题？
**Activity作为controller会导致代码膨胀。**  
1. layout布局文件是静态的，无法帮助activity处理数据的绑定。（后续的databinding、Jetpack compose帮助解决这个问题）
2. 本职工作，需要处理生命周期。（Jetpack lifecycle、viewmodel就是为了解决这个）
3. 需要分担异步任务的调度。
  
**Activity实例生命周期的问题，横竖屏翻转导致的实例重新创建，全局变量需要用onSaveInstance和onRestoreInstance来保存。不太符合直觉。**  
**startActivityForResult，导致需要在startActivityForResult处理跳转回来的问题。为啥不通过Callback？同样是因为Activity实例不可靠！！！！callback实例会丢失！！**

### 为什么Activity不能膨胀？
1. Activity会长期驻留在内存中，内容过多会占用内存。
2. 层次过厚，不利于解耦。

### MVP的相对于MVC的改变
1. 将Activity归于View层。即Activity回归UI本质，负责生命周期和数据绑定逻辑。
2. Presenter负责业务逻辑和异步任务调度。相当于进一步减轻Activity的压力。
3. Presenter依赖倒置Activity。

### MVP的好处
1. 用户行为统一有View接收，不会渗透到Controller;
2. 数据绑定和生命周期都被放在View，Presenter职责变清晰。
3. Presenter生命周期更短，不必和Activity绑定。
**单一职责，依赖倒置。解决代码膨胀、实现替换难、逻辑复用难。**

## MVVM是不是MVP+DataBinding？
MVVM和MVP最大的区别就是: **Presenter和View之间的依赖关系变成了View和ViewModel之间的绑定关系。**  
ViewModel的职责不再是业务逻辑，而是页面的建模。

### MVVM解决问题的思路
1. 页面建模。对页面状态和要展示的数据进行建模，比如正常态、loading态、error态。
2. 然后再根据建模分别构建页面和构建数据。
3. ViewModel和view是数据绑定，ViewModel和model是数据映射。
4. 关注点分离，并行式的去考虑View和Model的构建。而MVP就是闭环式的解决思路，View->Presenter->Model->View。

### DataBinding的作用
解决View和ViewModel的绑定，消除样板代码。能帮我们更好的实现MVVM，但不是实现MVVM的唯一方式。

### MVP vs MVVM
1. MVP更像是接口的提炼方式（依赖倒置）（组件化也能用到MVP），所以应用场景比较多。而MVVM更专注有页面的功能开发，专注于托管页面的状态和数据。
2. ViewModel是针对View的建模，导致View和ViewModel之间存在耦合。相比较MVP而言，不利于复用（不代表不能）。
3. Android官方推出的解决MVC的问题的工具，比如Databinding、livedata、Viewmodel，都符合MVVM思想。

## Jetpack给MVVM带来了什么？
### 什么是Jetpack？
多个库组成的套件，可以帮助开发者遵循最佳做法、减少样板代码并编写可在各种Android版本和设备中一致运行的代码。

### Jetpack MVVM
1. ViewModel:  
    感知生命周期一致性。**保证ViewModel和Activity生命周期保持一致，而不是和Activity的实例的生命周期一致！！！解决实例不可靠的情况**  
    **Fragment之间和Activity数据共享！！！**
    **当然ViewModel实例也可以只属于Fragment的。取决于ViewModelProvider.of(LifecycleOwner)，owner实现者是谁。**
2. LiveData: 感知Activity生命周期的数据持有者。  
    是理想的ViewModel中的数据成员。  
    a. 是唯一可信的源，降低数据绑定代码的复杂度（不用多次创建（想想callback的形式），不用考虑实时性）。  
    b. 观测改变，有利于双向绑定。  
    c. 生命周期感知，适合页面为主的功能开发。  
    d. 可映射，支持调停（mediator）模式，灵活性高。  

3. DataBinding: View和数据进行绑定。
    但是，View层需要关注大量不同的JavaBean，造成了View和Model的耦合。  
    xml中有数据映射逻辑，很难排查问题。
    所以mvvm里用Databinding，不能直接将业务bean放在xml里，要建模UI关注的状态和数据。  
4. 

### Jetpack View
1. Compose: 组合函数，DSL形式实现非xml的页面。
2. Material Design: MD风格的组件。
3. Paging3: 页面加载和分页库。
4. ViewPager2: 滑动形式的View或Fragment。

### Model
1. Room: 创建管理Sqlite持久化数据的ORM框架。
2. Work: 调度和排期后台任务。

### LifeCycle
通过模板方法模式和观察者模式解决**生命周期一致性**的问题。



## MVC、MVP、MVVM？
首先这三个是android代码常用的框架模式，为的是方便拓展和维护。  
**MVC**  
也就是Model-View-Controller。它用一种业务逻辑、数据、界面显示分离的方法组织代码。
1. Model: 针对业务所建立的数据结构和相关类。
2. View: 视图XML文件或者自定义View。
3. Controller: 通常是Activity、Fragment或者他们控制的其他类。  
   缺点: Activity还承载视图的功能，作为Controller会越来越臃肿。

**MVP**  
MVC的进化版本，解放Activity，使得Model和View彻底分离。
1. Model: 提供数据存取。供Presenter使用。
2. View: 负责处理用户事件和视图部分的展示。在Android中，它可以是Activity、Fragment或者某个View控件。
3. Presenter: 作为View和Model沟通的桥梁，从Model检索数据返回给View。使得View和Model之间没有耦合。  
   Presenter与具体的View没有关联，而是通过预先定义好的接口进行交互。View只有getter和setter。不允许View和Model直接交互。

**MVVM**
将Presenter换成ViewModel。将View和Model进行双向绑定。Android中实现ViewModel的工具为DataBinding、ViewModel。
## Databinding原理？
如果工程中使用了databinding，则会在编译期生成一下5个文件。假设我们的Activity是TestActivity，layout文件是activity_test.xml。  
**activity_test.xml**(build/intermediates/incremental/mergeDebugResources/stripped.dir/layout/activity_test.xml)   
去掉layout标签，只保留布局的xml，并且给每一个databinding的节点打上了tag。  
**activity_test-layout.xml**(build/intermediates/data_binding_layout_info_type_merge/debug/out/activity_test-layout.xml)  
是对layout信息的扩展，其中variable节点记录有关variable的详细信息，target节点记录view的详细信息。  
**BR.java**(/build/generated/source/kapt/debug/com/android/genshen/BR.java)  
主要根据<variable>和@Bindable注解的字段生成id。  
**DataBinderMapperImpl**(/build/generated/source/kapt/debug/com/android/genshen/DataBinderMapperImpl.java)  	
简单来说就是维护一组layout中的tag和本地id的映射关系，并且其中的getBinder方法也是ActivityTestBindingImpl实例化对象和获取实例的地方。  
**ActivityTestBindingImpl**(/build/generated/source/kapt/debug/com/android/genshen/databinding/ActivityTestBindingImpl.java)  
构造方法中对View进行绑定，获取保存View到的实例。

**1. binding.setData发生了什么？**  
这里指更新binding中variable里的bean。首先更新了ActivityTestBindingImpl的bean实例，并更新dirtyFlag。然后调用父类ViewDataBinding的**requestRebind**方法。  
requestRebind会先根据当前的LifeCycleOwner(Activity或者Fragment)的状态，如果至少是START，则继续，否则直接返回。然后判断mPendingRebind，是否有进行中的rebind，如果有直接返回，否则mPendingRebind=true，继续。最终调用mChoreographer.postFrameCallback或者mUIThreadHandler.post执行一个mRebindRunnable，区别是前者会在下一帧到来的时候肯定会执行该任务，而后者不能保证下一帧可以刷新生效。  
mRebindRunnable执行的是executeBindings，它是ViewDataBinding的抽象方法，最终实现在ActivityTestBindingImpl里，也就是根据前面的dirtyFlag执行视图的刷新，比如TextView.setText。  
**2. notifyPropertyChanged发生了什么？**  
不管是ObservableField还是自己在setter手动notifyChange，都是**观察者模式**的运用，通知观察者数据变化。跟databinding的观察者，是在binding.setData的时候，调用updateRegistration注册的。updateRegistration经过一系列调用最终其实就是向ObservableField注册OnPropertyChangeListener。数据改变会调用binding.handleFieldChange，然后调用**requestRebind**，完成对应视图更新。  
**3. View->Model的绑定怎么做到的？**  
一般双向绑定发生在editText。在ActivityTestBindingImpl的构造方法里，会把一个有关设置editText的TextWatcher的dirtyFlag位设置为1。后边binding.setData的时候，会根据这个dirtyFlag给editText注册TextWatcher，然后在TextWatcher里更新对应的数据，完成反向绑定。
## LiveData原理？
LiveData **是一个可观察的数据持有者，并且能够感知组件的生命周期。** 也就是说，如果组件处于DESTROY状态，则它不会收到通知。   
先看一下LiveData的常规用法：

	public class MainActivity extends AppCompatActivity {
   	private static final String TAG="MainActivity";
	    @Override
	    protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		MutableLiveData<String> mutableLiveData  = new MutableLiveData<>();
		mutableLiveData.observe(this, new Observer<String>() {//1
		    @Override
		    public void onChanged(@Nullable final String s) {
			Log.d(TAG, "onChanged:"+s);
		    }
		});
		mutableLiveData.postValue("Android进阶三部曲");//2
	    }
	}

**observe流程**：
1. oberve里会首先检查owner的状态，如果是DETROYED，则直接return。
2. 往下对lifecyclerOwner和observer进行封装ObserverWrapper，保存LifecycleBoundObserver并同时向lifecycleOwner生命周期注册观察者，也是此LifecycleBoundObserver。
3. LifecycleBoundObserver里，shouldBeActive方法用来判断当前组件owner是否是STARTED或者RESUMED状态。LifeCycle发生变化，会回调onStateChanged，其中如果state是DESTROYED，则会移除数据的observer。否则往下调用activeStateChanged。
4. activeStateChanged里有两个active状态转换的方法供外部覆写。然后调用dispatchingValue。
5. dispatchingValue里会调用到considerNotify。considerNotify会进行active状态的再次检查，然后调用传入的**observer的onChange方法**。

**setValue/postValue流程**：
1. set和post的区别是set只能在ui线程调用，post可以在子线程调用。二者最终都是调用dispatchingValue。
2. dispatchingValue也是前面observe会调用的方法。二者根据传参是否为Null有不同的流程。observe里只会回调当前observe传入的观察者，setValue会回调所有注册的观察者。逻辑上也是理所应当的。

## ViewModel原理？
**ViewModel特点**  
**ViewModel 是一个专门用于存储和管理与 UI 相关的数据的类**。
1. 当Activity被销毁时，我们可以使用onSaveInstanceState()方法恢复其数据，这种方法仅适用于恢复少量的支持序列化、反序列化的数据，不适用于大量数据，如用户列表或位图。而ViewModel不仅支持大量数据，还不需要序列化、反序列化操作。
2. Activity/Fragment（视图控制器）主要用于显示视图数据，如果它们也负责数据库或者网络加载数据等操作，那么一旦逻辑过多，会导致视图控制器臃肿，ViewModel可以更容易，更有效的将视图数据相关逻辑和视图控制器分离开来。
3. 视图控制器经常需要一些时间才可能返回的异步调用，视图控制器需要管理这些调用，在合适的时候清理它们，以确保它们的生命周期不会大于自身，避免内存泄漏。而ViewModel恰恰可以避免内存泄漏的发生。
   **ViewModel如何被创建的，在什么时候被销毁？**  
   通常在onCreate的时候：viewModel = ViewModelProvider(this).get(TestViewModel::class.java) 获取viewModel对象。  
   首先第一步获取一个ViewModelProvider对象。它的构造函数里通过传入的Activity/Fragment获取了两个对象，一个是属于Activity/Fragment的ViewModelStore，另一个是ViewModelProviderFactory，用来生成ViewModel实例的工厂类。  
   然后get方法里通过工厂类和传入的class类型，构造ViewModel实例，如果ViewModelStore里有实例，则用已有的，否则新建实例。  
   **ViewModel什么时候被销毁？**  
   在Activity里，通过向LifeCycle注册监听，在DESTROY事件的时候，清空自己的ViewModelStore的所有ViewModel。  
   在Fragment里，Fragment的ViewModel由FragmentManager的FragmentManagerViewModel统一管理，由FragmentStateManager状态机切换的时候触发destroy来销毁。  
   **为什么翻转屏幕，Activity可以保留ViewModel实例，不是走了Destroy流程吗？**  
   Activity有一个方法onRetainNonConfigurationInstance，这个方法由系统在Activity destroy的时候调用，比如翻转屏幕ComponentActivity覆写。覆写后，可以返回想要让系统存储的一个对象，viewModelStore就是在这里存储的。然后getViewModelStore里，会从NonConfigurationInstance里找之前的对象。  
   **Fragment如何共享数据？**  
   Fragment获取ViewModel的时候，传入Activity作为ViewModelProvider的入参就行，实际上共享的是Activity的ViewModel。
