## OKHttp

## Retrofit

## Glide

## ARouter

    @Route(path = RoutePath.USER_HOME)
    class UserHomeActivity : AppCompatActivity() {

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_user_home)
        }
    }
    //其它页面使用如下代码来跳转到 UserHomeActivity
    ARouter.getInstance().build(RoutePath.USER_HOME).navigation()

ARouter原理说白了就是如何通过注解定位到特定的组件。  
概括就是在编译阶段根据路由规则生成了path和对应class的映射关系文件。

    com.alibaba.android.arouter.routes
    
    public class ARouter$$Group$$account implements IRouteGroup {
        @Override
        public void loadInto(Map<String, RouteMeta> atlas) {
            atlas.put("/account/userHome", RouteMeta.build(RouteType.ACTIVITY, UserHomeActivity.class, "/account/userhome", "account", null, -1, -2147483648));
        }
    }

**ARouter基本思路**  
1. 开发者自己维护特定 path 和特定的目标类之间的对应业务关系，ARouter 只要求开发者使用包含了 path 的 @Route 注解修饰目标类。
2. ARouter 在编译阶段通过注解处理器来自动生成 path 和特定的目标类之间的对应关系，即将 path 作为 key，将目标类的 Class 对象作为 value 之一存到 Map 之中。
3. 在运行阶段，应用通过 path 来发起请求，ARouter 根据 path 从 Map 中取值，从而拿到目标类，以此来完成跳转。

**RouteMeta和Postcard**  
1. RouteMeta也就是路由元信息，包含路线类型（目标是Activity还是其他组件）、目标的Class信息、传参类型等等。  
2. Postcard集成自RouteMeta，额外包含uri、数据bundle等信息。
ARouter的build方法就是返回一个PostCard，然后调用navigation方法填充PostCard信息。

**注解处理器生成注册代码**  
使用APT处理@Route注解，生成路由元信息RouteMeta。生成java文件的时候会给RouteMeta分组，由注解中指定或者默认path的第一级。

**跳转流程**  
navigation会加载路由表（反射调用加载IRouteGroup，loadInto），查询RouteMeta并将RouteMeta填充到PostCard中。然后将条状事件交给拦截器处理，如果没有拦截，就按类型执行跳转动作。其中Provider和Fragment是跳过拦截器的。

**拦截器**
自己实现拦截器IInterceptor接口并且添加@Interceptor注解。拦截器有优先级之分，按照优先级依次处理。添加绿色通道的router不会走拦截器。  



## EventBus