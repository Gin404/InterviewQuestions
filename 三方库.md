## OKHttp
### 基本用法

    OkHttpClient client = new OkHttpClient();
    Request request = new Request.Builder().url("www.google.com").build();
    Response response = client.newCall(request).execute();
    return response.body().string();

1. 构造client;
2. 构造请求Request;
3. 处理请求（同步还是异步）;
4. 责任链模式处理请求和响应。

### 核心类
**OkHttpClient**: 这个是整个OkHttp的核心管理类，所有的内部逻辑和对象归OkHttpClient统一来管理，它通过Builder构造器生成。  
**Request 和Response**: Request是我们发送请求封装类，内部有url, header , method，body等常见的参数，Response是请求的结果，包含code, message, header,body ；这两个类的定义是完全符合Http协议所定义的请求内容和响应内容。  
**RealCall**: 负责请求的调度（同步的话走当前线程发送请求，异步的话则使用OkHttp内部的线程池进行）；同时负责构造内部逻辑责任链，并执行责任链相关的逻辑，直到获取结果。虽然OkHttpClient是整个OkHttp的核心管理类，但是真正发出请求并且组织逻辑的是RealCall类，它同时肩负了调度和责任链组织的两大重任。  

### 核心逻辑RealCall
execute和enqueue的区别就是后者做了一个异步处理，最终调用的都是execute。execute调用的是getResponseWithInterceptorChain()。  

### getResponseWithInterceptorChain()
首先添加7种拦截器Interceptor:
1. client.Interceptors: 用户自定义;
2. RetryAndFollowUpInterceptor: 失败和重定向拦截器; 请求过程抛异常是否要重试；响应回来3xx时构建新请求；
3. BridgeInterceptor: 封装request和response拦截器;
4. CacheInterceptor: 缓存相关的过滤器，负责读取缓存直接返回、更新缓存;
5. ConnectInterceptor: 连接服务，负责和服务器建立连接 这里才是真正的请求网络;
6. client.networkInterceptors: 用户自定义;
7. CallServerInterceptor: 行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据 进行http请求报文的封装与请求报文的解析;  

责任链模式会将每个interceptor的处理，**分为start、next.proceed、end这三个部分依次执行**，也就是说，每个责任链节点都能在下一个节点处理之前和之后添加自己的逻辑。  

###  Interceptors和NetworkInterceptors的区别？
从前面添加拦截器的顺序可以知道 Interceptors 和 networkInterceptors 刚好一个在 RetryAndFollowUpInterceptor 的前面，一个在后面。
结合前面的责任链调用图可以分析出来，假如一个请求在 RetryAndFollowUpInterceptor 这个拦截器内部重试或者重定向了 N 次，那么其内部嵌套的所有拦截器也会被调用N次，同样 networkInterceptors 自定义的拦截器也会被调用 N 次。而相对的 Interceptors 则一个请求只会调用一次，所以在OkHttp的内部也将其称之为 Application Interceptor。  
### BridgeInterceptor
1. 负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应，是从应用程序代码到网络代码的桥梁
2. 设置内容长度，内容编码
3. 设置gzip压缩，并在接收到内容后进行解压。省去了应用层处理数据解压的麻烦
4. 添加cookie
5. 设置其他报头，如User-Agent,Host,Keep-alive等。其中Keep-Alive是实现连接复用的必要步骤
### CacheInterceptor
1. 通过Request尝试到Cache中拿缓存，当然前提是OkHttpClient中配置了缓存，默认是不支持的。
2. 根据response,time,request创建一个缓存策略，用于判断怎样使用缓存。
3. 如果缓存策略中设置禁止使用网络，并且缓存又为空，则构建一个Response直接返回，注意返回码=504
4. 缓存策略中设置不使用网络，但是又缓存，直接返回缓存
5. 接着走后续过滤器的流程，chain.proceed(networkRequest)
6. 当缓存存在的时候，如果网络返回的Resposne为304，则使用缓存的Resposne。
7. 构建网络请求的Resposne 
8. 当在OkHttpClient中配置了缓存，则将这个Resposne缓存起来。
9. 缓存起来的步骤也是先缓存header，再缓存body。
10. 返回Response。
### ConnectInterceptor
简言之，就是最终获取一个已经建立连接的Socket对象，也就是说，在ConnectInterceptor内部已经完成了socket连接。  
在socket进行连接之前，其实还有一个dns的过程，也是隐含在findHealthConnection 里的内部逻辑。  


参考：https://juejin.cn/post/6844904102669844493#comment


## Retrofit

## Glide
图片加载框架，在加载图片的过程中做了很多的优化。整体流程如下：  
1. 封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程；
2. 解析路径：图片的来源有多种，格式也不尽相同，需要规范化；
3. 读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（Bitmap）即可；
4. 查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载；
5. 解码：这一步是整个过程中最复杂的步骤之一，有不少细节；
6. 变换：解码出Bitmap之后，可能还需要做一些变换处理（圆角，滤镜等）；
7. 缓存：得到最终bitmap之后，可以缓存起来，以便下次请求时直接取结果；
8. 显示：显示结果，可能需要做些动画（淡入动画，crossFade等）。

### 缓存机制
缓存分别内存缓存和磁盘缓存，细分有4种：
1. **活动缓存ActiveResources**: 如果当前对应的图片资源是从内存缓存中获取的，那么会将这个图片存储到活动资源中。
2. **内存缓存LruResourceCache**: 图片解析完成并最近被加载过，则放入内存中。
3. **磁盘缓存-资源类型DiskLruCacheWrapper**: 被解码后的图片写入磁盘文件中。
4. **磁盘缓存-原始数据DiskLruCacheWrapper**: 网络请求成功后将原始数据在磁盘中缓存。

*内存缓存*  
首先，key是由图片地址，宽高，变换，签名等元素生成的。  
ActiveResources 就是一个弱引用的 HashMap，需要使用图片资源的时候，用key从ActiveResources查找，如果没有，则从LruResourceCache查找，找到后将资源从LruResourceCache转移到ActiveResources里。  
ActiveResources会记录活动资源的引用数，如果为0，则将图片资源重新从ActiveResources移到LruResourceCache。  
**ActiveResources的目的是为了防止正在使用的资源被LruResourceCache删除掉！**

*磁盘缓存*  
磁盘缓存包括以下几种策略：
1. DiskCacheStrategy.NONE: 表示不缓存任何内容。
2. DiskCacheStrategy.RESOURCE: 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源。
3. DiskCacheStrategy.DATA: 在资源解码前将原始数据写入磁盘缓存。
4. DiskCacheStrategy.ALL: 使用DATA和RESOURCE缓存远程数据，仅使用RESOURCE来缓存本地数据。
5. DiskCacheStrategy.AUTOMATIC: 它会尝试对本地和远程图片使用最佳的策略。当你加载远程数据时，AUTOMATIC 策略仅会存储未被你的加载过程修改过的原始数据，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵得多。对于本地数据，AUTOMATIC 策略则会仅存储变换过的缩略图，因为即使你需要再次生成另一个尺寸或类型的图片，取回原始数据也很容易。默认使用这种缓存策略。

RESOURCE和DATA两种策略的key也不一样。  
RESOURCE是解码后的数据，key除了sourceKey，还有变换的一些参数比如宽高构成。  
DATA只有sourceKey和signature来构成key。  

### Glide内存优化
*Bitmap优化*  
1. 当图片大小与View大小不一致时，可以用inSampleSize进行尺寸优化，也就是对原图进行采样。
2. 图片所占内存即宽高每像素所占内存大小，不同的模式每个像素所占的内存大小不同，我们可以利用inpreferredconfig配置。不同格式的像素所需bit数不一样。
3. Bitmpa所占内存比较大，如果频繁创建回收Bitmap内存可能造成内存抖动，我们可以利用inBitmap利用Bitmap内存。
4. 内存缓存，比如Glide的弱引用缓存与LRU缓存。

**Glide实现**   
*a. 尺寸优化*  
图片原始大小为800*800，但是imageview只要100*100，那会有很多像素是多余的，容易造成OOM。
*b. 格式优化*
Bitmap内存大小 = 宽.高.每像素所占内存  
API29的像素格式有ALPHA_8, RGB_565, ARGB_4444, ARGB_8888, RGBA_F16, HARDWARE这几种，占用1、2、4、8字节的都有，可以根据需要调整根式。  
*c. 内存复用优化*  
**inBitmap**: 原生android提供的复用机制，在 Android 3.0（API 级别 11）开始，系统引入了 BitmapFactory.Options.inBitmap 字段。如果设置了此选项，那么采用 Options 对象的解码方法会在生成目标 Bitmap 时尝试复用 inBitmap，这意味着 inBitmap 的内存得到了重复使用，从而提高了性能，同时移除了内存分配和取消分配。不过 inBitmap 的使用方式存在某些限制，在 Android 4.4（API 级别 19）之前系统仅支持复用大小相同的位图，4.4 之后只要 inBitmap 的大小比目标 Bitmap 大即可。  
**BitmapPool**: Glide自己实现的池化方案。默认使用LruBitmapPool来进行池化，根据宽高和config类型存取复用对象。  

### 生命周期管理
为啥要进行生命周期管理？页面退出时，要终止请求，防止内存泄露。  
主要步骤：  
1. 通过Glide.with传入context,利用context构建一个Fragment。
2. 监听Fragment生命周期，销毁时释放Glide资源。

实现层面：
1. 在当前Activity添加一个透明Fragment用于管理请示生命周期。
2. 构建RequestManager并传入Fragment生命周期。
3. 在生命周期onStart时继续加载，onStop时暂停加载，onDestory时停止加载任务和清除操作。

参考：https://juejin.cn/post/6970683481127043085#heading-1



## ARouter

    @Route(path = RoutePath.USER_HOME)
    class UserHomeActivity : AppCompatActivity() {

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_user_home)
        }
    }
    //其它页面使用如下代码来跳转到 UserHomeActivity
    ARouter.getInstance().build(RoutePath.USER_HOME).navigation()

ARouter原理说白了就是如何通过注解定位到特定的组件。  
概括就是在编译阶段根据路由规则生成了path和对应class的映射关系文件。

    com.alibaba.android.arouter.routes
    
    public class ARouter$$Group$$account implements IRouteGroup {
        @Override
        public void loadInto(Map<String, RouteMeta> atlas) {
            atlas.put("/account/userHome", RouteMeta.build(RouteType.ACTIVITY, UserHomeActivity.class, "/account/userhome", "account", null, -1, -2147483648));
        }
    }

**ARouter基本思路**  
1. 开发者自己维护特定 path 和特定的目标类之间的对应业务关系，ARouter 只要求开发者使用包含了 path 的 @Route 注解修饰目标类。
2. ARouter 在编译阶段通过注解处理器来自动生成 path 和特定的目标类之间的对应关系，即将 path 作为 key，将目标类的 Class 对象作为 value 之一存到 Map 之中。
3. 在运行阶段，应用通过 path 来发起请求，ARouter 根据 path 从 Map 中取值，从而拿到目标类，以此来完成跳转。

**RouteMeta和Postcard**  
1. RouteMeta也就是路由元信息，包含路线类型（目标是Activity还是其他组件）、目标的Class信息、传参类型等等。  
2. Postcard集成自RouteMeta，额外包含uri、数据bundle等信息。
ARouter的build方法就是返回一个PostCard，然后调用navigation方法填充PostCard信息。

**注解处理器生成注册代码**  
使用APT处理@Route注解，生成路由元信息RouteMeta。生成java文件的时候会给RouteMeta分组，由注解中指定或者默认path的第一级。

**跳转流程**  
navigation会加载路由表（反射调用加载IRouteGroup，loadInto），查询RouteMeta并将RouteMeta填充到PostCard中。然后将条状事件交给拦截器处理，如果没有拦截，就按类型执行跳转动作。其中Provider和Fragment是跳过拦截器的。

**拦截器**
自己实现拦截器IInterceptor接口并且添加@Interceptor注解。拦截器有优先级之分，按照优先级依次处理。添加绿色通道的router不会走拦截器。  



## EventBus