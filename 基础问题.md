# 知识点
## 此文档旨在针对常问问题（知识点），每个问题总结一个300字左右的答案，不要长篇赘述。细节可以贴相关链接。

## 计算机基础
### 1. http与https有什么区别?
1. http和https的概念：  
HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（基于TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。  
HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。  
**HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。**  
2. https通信步骤  
- 首先服务器和客户端之间最终采用对称秘钥加密通信，但是认证过程涉及2组非对称加密。  
- 整个过程涉及两组秘钥，属于认证机构的非对称秘钥(K1, P1)，属于服务器的非对称秘钥(K2, P2)。K表示公钥，P表示私钥。  
- X.509证书: 由认证机构颁发，用于将加密秘钥和公司进行安全关联。包含：P1加密的服务端公钥K2，和P1加密的证书签名。
- 具体步骤：

	a. 服务器向权威机构申请证书。  
	b. 服务器把证书发给客户端。  
	c. 客户端用内置的K1，解密证书，验证签名，获取服务器公钥K2。  
	d. 客户端用K2加密自己的对称秘钥，发送给服务器。  
	e. 客户端和服务器用这一组对称秘钥进行通信。  

所以如果问到Charles抓包原理，关键在于证书上。把Charles证书安装在手机上后，手机把Charles当成服务器，完成一次https认证和通信；Charles作为客户端再和真正的服务器完成https认证和通信。

### 2. 浏览器输入一个域名发生了什么？  
1. 通过DNS解析IP地址  
	首先会找缓存，顺序：浏览器 -> 系统 -> 路由器 -> ISP；  
	没有的话，会向DNS服务器发送DNS查找请求。  
2. 浏览器查找本地是否存在缓存的Html，如果没有，则进行下一步TCP连接。  
3. 与 WEB 服务器建立 TCP 连接。  
	三次握手：  
	1. 客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND;  
	2. 服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；  
	3. 客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED 状态。连接建立，可以开始数据传输了。  

4. 如果是HTTPS的话，就进行加密认证。  
	
5. 浏览器发送请求获取页面html。  
6. 服务器响应html。  
7. 浏览器解析 HTML，渲染页面，执行js脚本等...  

## Android基础
### 1. Handler原理？

1. Looper 准备和开启循环

   - Looper#`prepare()` 初始化线程独有的 `Looper` 以及 `MessageQueue`
   - Looper#`loop()` 开启**死循环**读取 MessageQueue 中下一个满足执行时间的 Message
     - 尚无 Message 的话，调用 Native 侧的 `pollOnce()` 进入**无限等待**
     - 存在 Message，但执行时间 `when` 尚未满足的话，调用 pollOnce() 时传入剩余时长参数进入**有限等待**

2. Message 发送 、入队、出队

   Native 侧如果处于无限等待的话：任意线程向 `Handler` 发送 `Message` 或 `Runnable` 后，Message 将按照 when 条件的先后，被插入 Handler 持有的 Looper 实例所对应的 MessageQueue  中**适当的位置**。 MessageQueue 发现有合适的 Message 插入后将调用 Native 侧的 `wake()` 唤醒无限等待的线程。这将促使 MessageQueue 的读取继续**进入下一次循环**，此刻 Queue 中已有满足条件的 Message 则出队返回给 Looper

   Native 侧如果处于有限等待的话：在等待指定时长后 epoll_wait 将返回。线程继续读取 MessageQueue，此刻因为时长条件将满足将其出队

3. Looper 处理 Message 的实现

   Looper 得到 Message 后回调 Message 的 `callback` 属性即 Runnable，或依据 `target` 属性即 Handler，去执行 Handler 的回调。

   - 存在 `mCallback` 属性的话回调 `Handler$Callback`
   - 反之，回调 `handleMessage()`

   

   参考链接：https://juejin.cn/post/7054830013102686238#heading-0

   https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Handler%E6%9C%BA%E5%88%B6%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87.md

### 2. 同步屏障？Choreographer？  
1. 首先Messsage有一个参数isAsynchronous，当为true的时候，消息为异步消息，为false时，为同步消息。  
2. 当一个Message的target为null的时候，那他是一个**同步屏障**。开发者无法设置target为null，MessageQueue有一个postSyncBarrier的方法，但是是private的。  
3. 当MQ获取下一个message的时候，如果碰到了同步屏障，**那么不会取出同步屏障，而是往后遍历，跳过所有同步消息，取出下一个异步消息并执行**。  
4. 同步屏障的移除也是由MessageQueue完成，同样是private方法。  
**综上，理论上，开发者只能添加异步消息，但是不能自行添加/移除同步屏障。**  
**那系统何时添加同步屏障呢？**  
结合屏幕刷新机制和view绘制原理，手机接收VSYNC信号的时候（60hz手机每16.6ms一次）会执行view的绘制（measure、layout、draw）。具体原因就在于ViewRootImpl.scheduleTraversals。  
**ViewRootImpl.scheduleTraversals：ui变化都会走到此方法。**  
他干了两件事：向主线程handler发送一个屏障消息 和 向Choreographer注册一个runnable。  
这个runnable会作为异步消息在下一个vsync信号到来的时候被执行，他也是干了两件事：**移除同步屏障 和 performTraversals执行绘制流程**。  
**什么时候使用异步消息呢？**  
同步Handler有一个特点是会遵循与绘制任务的顺序，设置同步屏障之后，会等待绘制任务完成，才会执行同步任务；而异步任务与绘制任务的先后顺序无法保证，在等待VSYNC的期间可能被执行，也有可能在绘制完成之后执行。因此，我的建议是：如果需要保证与绘制任务的顺序，使用同步Handler；其他，使用异步Handler。
### 3. IdleHandler？调用时机？用处？
### 4. HandlerThread？
一个自带handler机制的线程，用于串行执行耗时任务。  
关键点在于run方法中mLooper = Looper.myLooper赋值的过程会加锁。getLooper方法中也会加锁，如果mLooper为空，则一直wait，直到Looper.myLooper执行完notifyAll，才会返回。所以能保证looper不会有空指针。
### 5. Vsync信号和Choreographer？
一般手机为60帧，也就是一秒会刷新60次，每16.6ms刷新一次。  
Vsync信号，一言以概之，就是一个同步一帧开始刷新的信号，**目的是为了让CPU/GPU充分的利用这16.6ms来进行下一帧数据的计算！**  
而编舞者**Choreographer就是用来监听这个Vsync信号并进行绘制动作的工具。**  
**Choreographer是线程单例的**，因为它要使用到当前线程的looper和handler机制。主线程的Choreographer在ViewRootImpl的构造函数中建立并持有。  
首先，一个事实是，不管是requestLayout还是ValueAnimator.start()还是invalidate，**最终都会走到scheduleTraversals来完成ui的更新**。  
scheduleTraversals做了**两件重要的事**：  
1. 向主线程handler发送一个同步屏障。  
2. 调用mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)。  

**Choreographer.postCallback的任务种类**  
CALLBACK_INPUT: 输入事件。  
CALLBACK_ANIMATION: 动画。  
CALLBACK_INSETS_ANIMATION: 插入动画。
CALLBACK_TRAVERSAL: 绘制。  
CALLBACK_COMMIT: 提交。  
5种事件会存入5个队列中，每当收到Vsync信号，Choreographer会依次按顺序执行5中事件。  

**接下来会最终执行到postCallbackDelayedInternal** 
该方法会将任务添加到对应的队列中，然后根据是否有延迟：  
    a. 如果没有延迟，直接执行**scheduleFrameLocked**。  
    b. 如果有延迟，则发送一个MSG_DO_SCHEDULE_CALLBACK类型的异步延迟消息到mHandler。前面已经设置了同步屏障，所以到时间后会立刻执行。
    mHandler会处理下面3种消息：  
        MSG_DO_FRAME：执行doFrame函数，也就是绘制流程。  
        MSG_DO_SCHEDULE_VSYNC：执行doScheduleVsync，申请VSYNC信号，例如当前需要绘制任务时。  
        MSG_DO_SCHEDULE_CALLBACK：执行doScheduleCallback。不出意外，doScheduleCallback最终还是执行的**scheduleFrameLocked**。  

**scheduleFrameLocked**  
判断是否开启了Vsync，Android4.1以上默认开启。  
如果开启，则调用**scheduleVsyncLocked**函数，不在主线程就往mHandler发送一个MSG_DO_SCHEDULE_VSYNC异步消息去调用。  
如果没开启，则需要自己计算一个下一帧的时间，然后发送一个MSG_DO_FRAME异步消息。

**执行doScheduleVsync**  
一句话，**通过FrameDisplayEventReceiver申请一个Vsync信号（回调）**，具体在native层实现，然后Vsync回来后，会调用onVsync。  
onVsync最终会通过mHandler发送一个MSG_DO_FRAME，也就是执行绘制流程.  

**doFrame**  
两个工作，一个是计算一下掉帧数，虽然执行doFrame的都是异步消息，但是前面有可能有**正在执行的同步消息没有执行完毕**，所以也有可能掉帧。  
另外一个，就是依次执行**5个任务队列**了。  

**CallbackRecord**
执行任务都会用doCallbacks方法。任务都会放在CallbackRecord里，然后调用他的run方法执行。根据参数中的token（一路传递下来的）有两种情况：  
token为null，则说明任务是个Runnable，直接执行他的run。比如doTraversal传过来的mTraversalRunnable就是这个。  
token是FRAME_CALLBACK_TOKEN，Choreographer的postFrameCallback传的就是这种类型的回调，回调类型是FrameCallback，消息类型是**CALLBACK_ANIMATION**。会执行FrameCallback.doFrame。  
说白了就是一个回调类型的判断。  
Choreographer.postFrameCallback通常会用来进行帧率的计算。

**mTraversalRunnable**  
**最后，mTraversalRunnable自然是执行performTraversals绘制三大流程。再次之前，还会移除同步屏障。**


### 6. invalidate/postInvalidate/requestLayout的区别？*
### 7. Fragment:replace和add的区别？show和hide？commit和commitAllowStateloss？
1. fragment容器为空的时候，replace和add没有区别。
   
2. 如果fragment容器有一个Fragment A。  
- 通过add添加Fragment B，生命周期变化如下：  
A: 无变化；  
B: onAttach 直到 onResume。  
此时，remove B，生命周期变化如下：  
A: 无变化；  
B: onPause 直到 onDetatch。  
（值得注意的是，如果同时调用了addToBackStack，B只会走到onDestroyView，此时通过findFragmentByTag依然可以找到FragmentB的实例。）   

- 通过replace添加Fragment B，生命周期变化如下：  
A: onPause 直到 onDetatch；  
B: onAttach 直到 onResume。  
在2处，通过findFragmentByTag可以找到A的实例。remove B，生命周期状态如下，  
A: 无变化；  
B: onPause 直到 onDetatch；  
(同样，如果同时调用了addToBackStack，B只会走到onDestroyView.)  

- **add和replace比较**  
1. 当Fragment不可见时，如果你要保留Fragment中的数据以及View的显示状态，那么可以使用add操作，后续中针对不同的状态隐藏和显示不同的Fragment。  
优点：快，只是Fragment中View的显示和隐藏。  
缺点：内存中保留的数据太多，容易导致造成OOM的风险。  
2. 当Fragment不可见时，你不需要保留Fragment中的数据以及View的显示状态，那么可以使用replace。  
优点：节省内存，不需要的数据能立即释放掉。  
缺点：频繁创建Fragment,也就是频繁走Fragment生命周期创建和销毁流程，造成性能开销。

- **commit和commitAlowStateloss**  
commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。  

- 参考文章  
  https://juejin.cn/post/6844903816240857095  
  https://juejin.cn/post/6943560702292557860
       

### 8. 事件分发机制？
分析滑动事件分发的4个重点：  
1. 滑动事件MotionEvent，一般需要关注3个事件种类：DOWN，UP，MOVE；  
2. dispatchTouchEvent  
作用是分发事件，如果一个事件分发到了一个view，则他的dispatchTouchEvent方法一定会被调用。返回结果取决于当前view的onTouchEvent和子View的dispatchTouchEvent，表示事件是否被消耗。
3. onInterceptTouchEvent。  
在dispatchTouchEvent方法内部调用，用于返回是否拦截这个事件。如果拦截，同一个事件序列不会再次调用此方法。  
4. onTouchEvent  
在dispatchTouchEvent方法中调用，用来处理点击事件。返回值代表是否消耗当前事件，如果消耗，则在当前事件序列中不会再调用此方法。  

下面伪代码可以表示事件分发的流程：  

	public boolean dispatchTouchEvent(MotionEvent ev) {
		boolean consume = false;
		if(onInterceptTouchEvent(ev)) {
			consume = onTouchEvent(ev);
		} else {
			consume = child.dispatchTouchEvent(ev);
		}
		return consume;
	}

一个MotionEvent的传递顺序：Activity->Window->View...  
**如果不做覆写，默认的事件传递流程：**  
Activity套MyViewGroup套MyView  
MainActivity: dispatchTouchEvent -> MyViewGroup: dispatchTouchEvent -> MyViewGroup: onInterceptTouchEvent -> MyView: dispatchTouchEvent -> MyView: onTouchEvent -> MyViewGroup: onTouchEvent -> MainActivity: TouchEvent  
其他一些要点：  
1. 事件序列以down为起点，中间有若干个move，最终以up为终点。  
2. 某个view一旦决定拦截，那整个事件序列一般只能由他来处理。  
3. 如果onTouchEvent处理down的时候返回false，则后续事件都不会再交给他处理。而是交由他的父view处理。  
**还有一些要点强烈建议看《Android开发艺术探索》。**

### 9. onTouchListener.onTouch、onTouchEvent、onClickListener.onClick优先级？
优先级其实是处理顺序：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。  
其中onTouchEvent是否被调用取决于onTouchListener.onTouch的返回值。onClickListener是在onTouchEvent里处理up事件的时候调用的。  
### 10. 滑动冲突如何解决？  
**两种方式**    
1.外部拦截法。   
父容器改动：

	public boolean onInterceptTouchEvent(MotionEvent event) {
		boolean intercepted = false;
		int x = (int) event.getX();
		int y = (int) event.getY();
		switch (event.getAction()) {
		    case MotionEvent.ACTION_DOWN:
			intercepted = false;
			break;
		    case MotionEvent.ACTION_MOVE:
			if (父容器需要当前点击事件) {
			    intercepted = true;
			} else {
			    intercepted = false;
			}
			break;
		    case MotionEvent.ACTION_UP:
			intercepted = false;
			break;
		    default:
			break;
		}
		mLastXIntercept = x;
		mLastYIntercept = y;
		return intercepted;
	}

注意，down事件返回false是因为一旦拦截，后续事件都会交给自己处理，返回false可以给子view处理事件的机会，毕竟我们只按需拦截move事件。  
一旦拦截了一个move事件，后续事件都会被自己处理。up也要返回false，否则子view没法触发onClick事件。  
2.内部拦截法。  
子容器的改动：

	public boolean dispatchTouchEvent(MotionEvent event) {
		int x = (int) event.getX();
		int y = (int) event.getY();
		switch (event.getAction()) {
		    case MotionEvent.ACTION_DOWN:
			parent.requestDisallowInterceptTouchEvent(true);
			break;
		    case MotionEvent.ACTION_MOVE:
			int deltaX = x - mLastX;
			int deltaY = y - mLastY;
			if (父容器需要此类点击事件)){
			parent.requestDisallowInterceptTouchEvent(false);
		    }
		    break;
		    case MotionEvent.ACTION_UP:
			break;
		    default:
			break;
		}
		mLastX = x;
		mLastY = y;
		return super.dispatchTouchEvent(event);
    	}

父容器的改动：  

	public boolean onInterceptTouchEvent(MotionEvent event) {
		int action = event.getAction();
		if(action == MotionEvent.ACTION_DOWN) {
			return false;
		} else {
			return true;
		}
	}

主要是子view通过requestDisallowInterceptTouchEvent来决定父view是否拦截事件，但是这个方法对于down事件没有用（因为父view会在down到来的时候重置disallow标记位），所以需要父view单独处理down事件。

### 11. Fragment通信方式？
### 12. MVC、MVP、MVVM？
首先这三个是android代码常用的框架模式，为的是方便拓展和维护。
**MVC**  
也就是Model-View-Controller。它用一种业务逻辑、数据、界面显示分离的方法组织代码。  
1. Model: 针对业务所建立的数据结构和相关类。  
2. View: 视图XML文件或者自定义View。  
3. Controller: 通常是Activity、Fragment或者他们控制的其他类。  
缺点: Activity还承载视图的功能，作为Controller会越来越臃肿。  
**MVP**  
MVC的进化版本，解放Activity，使得Model和View彻底分离。  
1. Model: 提供数据存取。供Presenter使用。  
2. View: 负责处理用户事件和视图部分的展示。在Android中，它可以是Activity、Fragment或者某个View控件。 
3. Presenter: 作为View和Model沟通的桥梁，从Model检索数据返回给View。使得View和Model之间没有耦合。  
Presenter与具体的View没有关联，而是通过预先定义好的接口进行交互。View只有getter和setter。不允许View和Model直接交互。  
**MVVM** 
将Presenter换成ViewModel。将View和Model进行双向绑定。Android中实现ViewModel的工具为DataBinding、ViewModel。  
### 13. Databinding原理？
如果工程中使用了databinding，则会在编译期生成一下5个文件。假设我们的Activity是TestActivity，layout文件是activity_test.xml。  
**activity_test.xml**(build/intermediates/incremental/mergeDebugResources/stripped.dir/layout/activity_test.xml)   
去掉layout标签，只保留布局的xml，并且给每一个databinding的节点打上了tag。  
**activity_test-layout.xml**(build/intermediates/data_binding_layout_info_type_merge/debug/out/activity_test-layout.xml)  
是对layout信息的扩展，其中variable节点记录有关variable的详细信息，target节点记录view的详细信息。  
**BR.java**(/build/generated/source/kapt/debug/com/android/genshen/BR.java)  
主要根据<variable>和@Bindable注解的字段生成id。  
**DataBinderMapperImpl**(/build/generated/source/kapt/debug/com/android/genshen/DataBinderMapperImpl.java)  	
简单来说就是维护一组layout中的tag和本地id的映射关系，并且其中的getBinder方法也是ActivityTestBindingImpl实例化对象和获取实例的地方。  
**ActivityTestBindingImpl**(/build/generated/source/kapt/debug/com/android/genshen/databinding/ActivityTestBindingImpl.java)  
构造方法中对View进行绑定，获取保存View到的实例。   
	
**1. binding.setData发生了什么？**  
这里指更新binding中variable里的bean。首先更新了ActivityTestBindingImpl的bean实例，并更新dirtyFlag。然后调用父类ViewDataBinding的**requestRebind**方法。  
requestRebind会先根据当前的LifeCycleOwner(Activity或者Fragment)的状态，如果至少是START，则继续，否则直接返回。然后判断mPendingRebind，是否有进行中的rebind，如果有直接返回，否则mPendingRebind=true，继续。最终调用mChoreographer.postFrameCallback或者mUIThreadHandler.post执行一个mRebindRunnable，区别是前者会在下一帧到来的时候肯定会执行该任务，而后者不能保证下一帧可以刷新生效。  
mRebindRunnable执行的是executeBindings，它是ViewDataBinding的抽象方法，最终实现在ActivityTestBindingImpl里，也就是根据前面的dirtyFlag执行视图的刷新，比如TextView.setText。  
**2. notifyPropertyChanged发生了什么？**  
不管是ObservableField还是自己在setter手动notifyChange，都是**观察者模式**的运用，通知观察者数据变化。跟databinding的观察者，是在binding.setData的时候，调用updateRegistration注册的。updateRegistration经过一系列调用最终其实就是向ObservableField注册OnPropertyChangeListener。数据改变会调用binding.handleFieldChange，然后调用**requestRebind**，完成对应视图更新。  
**3. View->Model的绑定怎么做到的？**  
一般双向绑定发生在editText。在ActivityTestBindingImpl的构造方法里，会把一个有关设置editText的TextWatcher的dirtyFlag位设置为1。后边binding.setData的时候，会根据这个dirtyFlag给editText注册TextWatcher，然后在TextWatcher里更新对应的数据，完成反向绑定。
### 14. LiveData原理？
LiveData **是一个可观察的数据持有者，并且能够感知组件的生命周期。** 也就是说，如果组件处于DESTROY状态，则它不会收到通知。   
先看一下LiveData的常规用法：

	public class MainActivity extends AppCompatActivity {
   	private static final String TAG="MainActivity";
	    @Override
	    protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		MutableLiveData<String> mutableLiveData  = new MutableLiveData<>();
		mutableLiveData.observe(this, new Observer<String>() {//1
		    @Override
		    public void onChanged(@Nullable final String s) {
			Log.d(TAG, "onChanged:"+s);
		    }
		});
		mutableLiveData.postValue("Android进阶三部曲");//2
	    }
	}
	
**observe流程**：	
1. oberve里会首先检查owner的状态，如果是DETROYED，则直接return。  
2. 往下对lifecyclerOwner和observer进行封装ObserverWrapper，保存LifecycleBoundObserver并同时向lifecycleOwner生命周期注册观察者，也是此LifecycleBoundObserver。  
3. LifecycleBoundObserver里，shouldBeActive方法用来判断当前组件owner是否是STARTED或者RESUMED状态。LifeCycle发生变化，会回调onStateChanged，其中如果state是DESTROYED，则会移除数据的observer。否则往下调用activeStateChanged。  
4. activeStateChanged里有两个active状态转换的方法供外部覆写。然后调用dispatchingValue。  
5. dispatchingValue里会调用到considerNotify。considerNotify会进行active状态的再次检查，然后调用传入的**observer的onChange方法**。  

**setValue/postValue流程**：  
1. set和post的区别是set只能在ui线程调用，post可以在子线程调用。二者最终都是调用dispatchingValue。  
2. dispatchingValue也是前面observe会调用的方法。二者根据传参是否为Null有不同的流程。observe里只会回调当前observe传入的观察者，setValue会回调所有注册的观察者。逻辑上也是理所应当的。  

### 15. ViewModel原理？
**ViewModel特点**  
1. 当Activity被销毁时，我们可以使用onSaveInstanceState()方法恢复其数据，这种方法仅适用于恢复少量的支持序列化、反序列化的数据，不适用于大量数据，如用户列表或位图。而ViewModel不仅支持大量数据，还不需要序列化、反序列化操作。  
2. Activity/Fragment（视图控制器）主要用于显示视图数据，如果它们也负责数据库或者网络加载数据等操作，那么一旦逻辑过多，会导致视图控制器臃肿，ViewModel可以更容易，更有效的将视图数据相关逻辑和视图控制器分离开来。  
3. 视图控制器经常需要一些时间才可能返回的异步调用，视图控制器需要管理这些调用，在合适的时候清理它们，以确保它们的生命周期不会大于自身，避免内存泄漏。而ViewModel恰恰可以避免内存泄漏的发生。
**ViewModel如何被创建的，在什么时候被销毁？**  
通常在onCreate的时候：viewModel = ViewModelProvider(this).get(TestViewModel::class.java) 获取viewModel对象。  
首先第一步获取一个ViewModelProvider对象。它的构造函数里通过传入的Activity/Fragment获取了两个对象，一个是属于Activity/Fragment的ViewModelStore，另一个是ViewModelProviderFactory，用来生成ViewModel实例的工厂类。  
然后get方法里通过工厂类和传入的class类型，构造ViewModel实例，如果ViewModelStore里有实例，则用已有的，否则新建实例。  
**ViewModel什么时候被销毁？**  
在Activity里，通过向LifeCycle注册监听，在DESTROY事件的时候，清空自己的ViewModelStore的所有ViewModel。  
在Fragment里，Fragment的ViewModel由FragmentManager的FragmentManagerViewModel统一管理，由FragmentStateManager状态机切换的时候触发destroy来销毁。  
**为什么翻转屏幕，Activity可以保留ViewModel实例，不是走了Destroy流程吗？**  
Activity有一个方法onRetainNonConfigurationInstance，这个方法由系统在Activity destroy的时候调用，比如翻转屏幕ComponentActivity覆写。覆写后，可以返回想要让系统存储的一个对象，viewModelStore就是在这里存储的。然后getViewModelStore里，会从NonConfigurationInstance里找之前的对象。  
**Fragment如何共享数据？**  
Fragment获取ViewModel的时候，传入Activity作为ViewModelProvider的入参就行，实际上共享的是Activity的ViewModel。

### 16. 动画？原理？
**属性动画ValueAnimator**  

    val valueAnimator = ValueAnimator.ofFloat(0f,500f,200f,400f)
    valueAnimator.setDuration(5000)
    valueAnimator.addUpdateListener {
        val currentValue:Int = (it.animatedValue as Float).toInt()
        Log.d(TAG, "start: currentValue = ${currentValue}")
        imageView.layout(currentValue,
            currentValue,
            currentValue + imageView.width,
            currentValue + imageView.height)
    }
    valueAnimator.start()

ValueAnimator内部会将传入的数组，比如上面的例子0f，500f，200f，400f，封装成PropertyValuesHolder保存下来，内涵一个key（默认为""）和这组数值。  
核心在于**start**方法。  
**start**  
获取**AnimationHandler**实例（线程单例），并且把自己作为回调参数传进AnimationHandler.addAnimationFrameCallback方法里。  
AnimationHandler维护了一组mAnimationCallbacks，首次调用addAnimationFrameCallback时，mAnimationCallbacks大小是0，会调用MyFrameCallbackProvider.postFrameCallback，参数是**Choreographer.FrameCallback**。  
这块儿就到了Choreographer，回顾一下之前postCallback的种类，这里传入的就是**CALLBACK_ANIMATION**，**也就是说注册并接收到Vsync信号后，动画的工作就开始了，接下来就执行AnimationHandler里实现的Choreographer.FrameCallback**。  
Choreographer.FrameCallback的实现由两件事，  
    1. 执行doAnimationFrame。  
    2. 申请下一个Vsync。  

所以重点看AnimationHandler.doAnimationFrame做了啥。
    1. 去循环遍历列表mAnimationCallbacks，取出每一个 回调ValueAnimator，然后判断动画是否有设置了延迟开始，或者说动画是否到时间该执行了，如果到时间执行了，那么就会去调用 ValueAnimator 的 doAnimationFrame()；  
    2. 清理mAnimationCallbacks。ValueAnimator动画执行完毕后，会通知AnimationHandler把列表中自己的位置设为null。这样每次清理的时候，会remove所有null。  

循环遍历mAnimationCallbacks，执行ValueAnimator.doAnimationFrame，这个函数就是每一帧动画的实现：  
    1. 处理第一帧动画的一些工作，确定当前动画的起始时间，后续动画都要以此为基准。  
    2. 根据当前时间计算当前帧的动画进度，所以动画的核心应该就是在 animateBaseOnTime() 这个方法里，意义就类似 Animation 动画的 getTransformation()方法；
    3. 判断动画是否已经结束了，结束了就去调用 endAnimation()，按照我们之前的猜测，这个方法内应该就是将当前动画从 mAniamtionCallbacks 列表里移除。  

**animateBaseOnTime**是真正完成动画进度更新的方法。这里简要概述就是，**会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后映射到对应的数值。这样我们在onAnimationUpdate里就能获取到对应数值。**  
详细分析见：https://juejin.cn/post/6844903585893859336  

**属性动画ObjectAnimator**  
ObjectAnimator继承自ValueAnimator。它的工厂方法有三个参数：  
target: Object类型，属性作用对象。  
property: Property<T, V>类型，有枚举值供选择，T代表声明该属性的类，V代表属性的类型。弱引用持有，所以不用担心内存泄露的问题，比如View。  
values: 属性动画的数值。  

概括下来，ObjectAnimator覆写了animateValue方法，在每一帧的时候通过Property更改target对应属性的数值，来完成动画。这是和ValueAnimator最大的区别。  

## android原生源码（一些常用工具类或者View的源码）
### 1. SharedPreferences是不是进程安全的？
不是。但是有一个已经废弃的多进程模式 MODE_MULTI_PROCESS。 MODE_MULTI_PROCESS的时候，会在获取sp对象后进行一个判断：  
如果   
  mDiskWritesInFlight>0，也就是当前有未完成的写入磁盘的任务；  
  文件上次操作的时间和大小（可能是另一个进程）和缓存的本进程上次时间和大小对不上；  
就重新从磁盘读取并解析xml。但是这并不能保证实时性，进程A读取完，进程B仍然有可能更新文件。  

**SharedPreferences原理**  
知识点1： 获取SharedPreferences对象的方法--Context.getSharedPreferences(String name, int mode)。  
要点：  
1. 每个路径path对应的File会有缓存，file对应的SharedPreferencesImpl也有缓存。  
2. 通过path获取到file，最终再通过file获取到SharedPreferencesImpl对象，这个过程是线程安全的。  
3. 有一个多进程模式，但是已经被弃用，谷歌明确表示此模式不可靠。具体实现是通过获取文件当前的时间戳和大小与上次的比较来判断是否需要重新从磁盘加载file。  

知识点2：SharedPreferencesImpl。  
1. 构造函数：  
    a. 或根据当前file创建一个灾备文件。  
    b. mMap：用于存储从file解析出来的键值对。  
    c. 加载并解析xml键值对，此过程是在新的线程里异步进行的。  

2. 异步加载方法：loadFromDisk。  
    a. 如果灾备文件存在，就删除原文件，把灾备文件命名为原文件。  
    b. 加载/解析键值对，存入mMap。记录文件修改时间、文件大小。  
    c. 此过程加锁，load完会notifyAll。(对象锁A)  

知识点3：getString(String key, @Nullable String defValue)。  
1. 加锁，await等待load过程结束，线程安全。（对象锁A）  
2. 直接操作内存mMap中的值。  

知识点4：putString(String key, @Nullable String value)。  
1. 定义在内部类Editor里。  
2. 并不是直接操作mMap，Editor自带一个mModified，用于存储写操作的键值对。  
3. 加锁。(对象锁B)  

知识点5：commit()  
1. 首先把mModified合并到mMap里。  
    a. 有一个重要参数叫mDiskWritesInFlight，代表“此时需要将数据写入磁盘，但还未处理或未处理完成的次数”，唯独在合并之前会+1。  
2. 调用enqueueDiskWrite写入到磁盘上。此方法用一个countDownLatch同步等待写入过程。写入过程完成，才会conuntDown，在commit里往下走。  
    a. 写入磁盘加锁（对象锁C）。  
    b. 写入后，mDiskWritesInFlight会减1。  
    c. 重要：对于commit而言，如果只有一个commit请求，那就在当前线程处理写入过程；如果有多个，那就放在QueuedWork里处理。  
    d. 写入磁盘的时候，会对老文件进行灾备（重命名），然后一次性写入所有数据。如果成功就删除灾备文件，并记录时间、大小；否则删除这个半成品。  


知识点6：apply()  
1. 首先把mModified合并到mMap里。合并过程和commit没区别。  
2. 注意！这里countDownLatch.await放在了一个awaitCommit的runnable里。最终放在QueueWork里。  
3. 同时，enqueueDiskWrite里的磁盘写入工作，也是放在QueueWork里。  

**关键词**：  
1. 全量从磁盘读取xml键值对，放入内存。  
2. 读写分离，不共用一把锁。  
3. put操作先更新mModified，commit/apply后，合并mMap，更新磁盘。  
4. apply是异步更新，但是也会有anr，具体原因参考：https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484387&idx=1&sn=e3c8d6ef52520c51b5e07306d9750e70&scene=21#wechat_redirect  

参考文章：  
https://juejin.cn/post/6844903758355234824#comment  
https://juejin.cn/post/6884505736836022280  

### 2. AsyncTask？

### 3.RecyclerView？
**关键成员变量**  
mLayout: RecyclerView.LayoutManager类型，负责布局。
mState: RecyclerView.State类型。保存了很多状态位。其中mState.mLayoutStep有三种状态STEP_START，STEP_LAYOUT，STEP_ANIMATIONS。满足一个状态转移过程：**STEP_START -> dispatchLayoutStep1 -> STEP_LAYOUT -> dispatchLayoutStep2 -> State.STEP_ANIMATIONS -> dispatchLayoutStep3 -> STEP_START.**  
mAdapter: RecyclerView.Adapter类型。负责ViewHolder的创建和数据绑定。  
mRecycler: RecyclerView.Recycler类型。负责VH的复用，也就是缓存池，是缓存机制的核心。

**3大layout方法作用**  
dispatchLayoutStep1: 本方法的作用主要有三点：  
    1.处理Adapter更新;  
    2.决定是否执行ItemAnimator;  
    3.保存ItemView的动画信息。本方法也被称为preLayout(预布局)，当Adapter更新了，这个方法会保存每个ItemView的旧信息(oldViewHolderInfo)  
dispatchLayoutStep2: 在这个方法里面，真正进行children的测量和布局。  
dispatchLayoutStep3: 这个方法的作用执行在dispatchLayoutStep1方法里面保存的动画信息。  


**onMeasure过程**  
分3种情况：  
1. **当mLayout为空的时候**，会按照specMode测量尺寸，但是onLayout阶段不会布局，也就是不会有数据显示。所以这个mLayout也是我们每次初始化Rv必传的参数。  
2. **当LayoutManager开启了自动测量**。常用的LinearLayoutManager是开启的。会依次执行dispatchLayoutStep1、dispatchLayoutStep2，如果需要二次测量，还需要执行dispatchLayoutStep2。  
   dispatchLayoutStep1和动画有关，第一次加载数据，是不会执行动画的。这个方法先按下不表。  
   dispatchLayoutStep2真正负责layoutChildren. 先通过mAdapter获取itemCount，然后调用mLayout.onLayoutChildren(mRecycler, mState)。onLayoutChildren由各个RecyclerView.LayoutManager子类实现，比如我们常用的LinearLayoutManager。  
3. **当没有开启自动测量。** 如果mHasFixedSize为true(也就是调用了setHasFixedSize方法)，将直接调用LayoutManager的onMeasure方法进行测量。如果mHasFixedSize为false，同时此时如果有数据更新，先处理数据更新的事务，然后调用LayoutManager的onMeasure方法进行测量。  

**onLayout过程**  
onLayout主要调用dispatchLayout。
dispatchLayout主要保证RV必须经历的3大步骤，dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。  
RecyclerView跟其他ViewGroup不同的地方在于，如果开启了自动测量，在measure阶段，已经将Children布局完成了；如果没有开启自动测量，则在layout阶段才布局Children。

**onDraw**  
draw干了三件事：  
1. 调用super.draw方法。这里主要做了两件事：  
   a. 将Children的绘制分发给ViewGroup;  
   b. 将分割线的绘制分发给ItemDecoration。  
2. 如果需要的话，调用ItemDecoration的onDrawOver方法。通过这个方法，我们在每个ItemView上面画上很多东西。  
3. 如果RecyclerView调用了setClipToPadding,会实现一种特殊的滑动效果--每个ItemView可以滑动到padding区域。  

RV的绘制流程看起来比较简单，但具体在LayoutManager里实现的layoutChildren是比较复杂的。直接看一下LinearLayoutManager的实现。  

**LinearLayoutManager.onLayoutChildren！！！！！！**  
关联成员：  
mAnchorInfo: LinearLayoutManager.AnchorInfo类型的数据类。用于保存锚点信息。锚点信息在LLM执行layout时候，可以提供参考。  

**1. 先更新锚点信息，mAnchorInfo的计算**  
三种方式：  
1. 第一种计算方式，表示含义有两种：1.RecyclerView被重建，期间回调了onSaveInstanceState方法，所以目的是为了恢复上次的布局；2.RecyclerView调用了scrollToPosition之类的方法，所以目的是让
RecyclerView滚到准确的位置上去。所以，锚点的信息根据上面的两种情况来计算。
2. 第二种计算方法，从Children上面来计算锚点信息。这种计算方式也有两种情况：1. 如果当前有拥有焦点的Child，那么有当前有焦点的Child的位置来计算锚点；2. 如果没有child拥有焦点，那么根据布局方向(此时布局方向由mLayoutFromEnd来决定)获取可见的第一个ItemView或者最后一个ItemView。
3. 如果前面两种方式都计算失败了，那么采用第三种计算方式，也就是默认的计算方式。


**2. 调用detachAndScrapAttachedViews对所有itemView进行回收**  
涉及到缓存机制，后续再说。

**3. 根据锚点的布尔值mLayoutFromEnd（填充方向）和锚点（填充位置）信息，去用fill填充children**  
需要知道的是，不管是哪个方向，都需要两次fill。以mLayoutFromEnd==true为例，先从锚点向start填充，再从锚点向end填充。  
fill方法内，会计算可用空间，然后循环调用**layoutChunk**来完成单个child的填充动作。layoutChunk步骤如下：  
1) 调用LayoutState的**next**方法获得一个ItemView。千万别小看这个next方法，RecyclerView缓存机制的起点就是从这个方法开始，可想而知，这个方法到底为我们做了多少事情。
2) 如果RecyclerView是第一次布局Children的话(layoutState.mScrapList == null为true)，会先调用addView，将View添加到RecyclerView里面去。
3) 调用measureChildWithMargins方法，测量每个ItemView的宽高。注意这个方法测量ItemView的宽高考虑到了两个因素：1.margin属性；2.ItemDecoration的offset。
4) 调用layoutDecoratedWithMargins方法，布局ItemView。这里也考虑上面的两个因素的。

**缓存机制！！！！！！！**
**四级缓存**  
一级: mAttachedScrap和mChangedScrap。均在Recycler中。其中mAttachedScrap存储的是当前还在屏幕中的ViewHolder，mChangedScrap存储的是数据被更新的ViewHolder,比如说调用了Adapter的notifyItemChanged方法。  
二级: mCachedViews。默认大小为2，通常用来存储预取的ViewHolder，同时在回收ViewHolder时，也会可能存储一部分的ViewHolder，这部分的ViewHolder通常来说，意义跟一级缓存差不多。  
三级: ViewCacheExtension。自定义缓存,通常用不到。  
四级: RecyclerViewPool。根据ViewType来缓存ViewHolder，每个ViewType的数组大小为5，可以动态的改变。  

**VH的状态**  
VH自身有很多状态机  
isInvalid: 对应FLAG_INVALID，表示当前ViewHolder是否已经失效。通常来说，在3种情况下会出现这种情况：  
    1.调用了Adapter的notifyDataSetChanged方法；  
    2. 手动调用RecyclerView的invalidateItemDecorations方法；  
    3. 调用RecyclerView的setAdapter方法或者swapAdapter方法。  
isRemoved: 对应FLAG_REMOVED，表示当前的ViewHolder是否被移除。通常来说，数据源被移除了部分数据，然后调用Adapter的notifyItemRemoved方法。  
isBound: 对应FLAG_BOUND，表示当前ViewHolder是否已经调用了onBindViewHolder。  
isTmpDetached: 对应FLAG_TMP_DETACHED，表示当前的ItemView是否从RecyclerView(即父View)detach掉。通常来说有两种情况下会出现这种情况：  
    1. 手动了RecyclerView的detachView相关方法；  
    2. 在从mHideViews里面获取ViewHolder,会先detach掉这个ViewHolder关联的ItemView。mHideViews先按下不表。  
isScrap: 无Flag来表示该状态，用mScrapContainer是否为null来判断。表示是否在mAttachedScrap或者mChangedScrap数组里面，进而表示当前ViewHolder是否被废弃。  
isUpdated: 对应FLAG_UPDATE。表示当前ViewHolder是否已经更新。通常来说，在3种情况下会出现情况：  
    1. isInvalid方法存在的三种情况；  
    2. 调用了Adapter的onBindViewHolder方法；  
    3. 调用了Adapter的notifyItemChanged方法。  

**复用和回收**  
*复用*  
前面提到的layout一个child的layoutChunk方法，获取用到的VH是用的LayoutState.next方法。  
next方法里，先忽略从scrapList获取VH的逻辑。主要逻辑是通过recycler.getViewForPosition获取下一个itemView。最终会调用到tryGetViewHolderForPositionByDeadline。  
过程大致如下：
    - 如果是preLayout阶段，也就是**dispatchLayout1**过程中，则从**mChangedScrap**里获取；前面提到只有当ItemAnimator不为空，被changed的ViewHolder会放在mChangedScrap数组里面。这里可以理解为change动画前后的VH是不同的，所以当预布局时，从mChangedScrap缓存里面去，而正式布局时，不会从mChangedScrap缓存里面去，这就保证了动画前后相同位置上是不同的VH。关于细节后续再提。  
    - 如果没有获取到，则分别从**mAttachedScrap、 mHiddenViews、mCachedViews**获取ViewHolder。如果获取的ViewHolder是无效的，得做一些清理操作，然后重新放入到缓存里面，具体对应的缓存就是mCacheViews（二级）和RecyclerViewPool（四级）。回收操作后续讲。  
    - 前面是通过position获取VH，如果position没有获取到VH，则用viewType来获取。前面position能获取到，viewType也会是正确的。  
    首先会判断Adapter的hasStableIds的返回结果，如果是true，则优先通过ViewType和id两个条件来寻找（从mAttachedScrap和mCachedViews里）。id是在adapter的实现类里覆写getItemId方法获取的。  
    如果为false，首先会在ViewCacheExtension里面找，如果还没有找到的话，最后会在RecyclerViewPool里面来获取ViewHolder。**RecyclerViewPool用SparseArray维护了每个ViewType对应的VH数组，每个数组最大size是5。**这里就是根据viewType去找取一个VH。  
    如果以上的复用步骤都没有找到合适的ViewHolder，最后就会调用**Adapter的onCreateViewHolder**方法来创建一个新的ViewHolder。
    

*回收*  
1. 回收到scrap。  
    主要看scrapView的调用时机。  
   1) 在getScrapOrHiddenOrCachedHolderForPosition方法里面，如果从mHiddenViews获得一个ViewHolder的话，会先将这个ViewHolder从mHiddenViews数组里面移除，然后调用Recycler的scrapView方法将这个ViewHolder放入到scrap数组里面，并且标记FLAG_RETURNED_FROM_SCRAP和FLAG_BOUNCED_FROM_HIDDEN_LIST两个flag。  
   2) 在LayoutManager里面的scrapOrRecycleView方法也会调用Recycler的scrapView方法。而有两种情形下会出现如此情况：1. 手动调用了LayoutManager相关的方法;2. RecyclerView进行了一次布局(调用了requestLayout方法)  

2. 回收到mCacheViews。  
    主要看recycleViewHolderInternal的调用时机。  
   1) 在重新布局回收了。这种情况主要出现在调用了Adapter的notifyDataSetChange方法,并且此时Adapter的hasStableIds方法返回为false。从这里看出来，为什么notifyDataSetChange方法效率为什么那么低，同时也知道了为什么重写hasStableIds方法可以提高效率。因为notifyDataSetChange方法使得RecyclerView将回收的ViewHolder放在二级缓存，效率自然比较低。  
   2) 在复用时，从一级缓存里面获取到ViewHolder，但是此时这个ViewHolder已经不符合一级缓存的特点了(比如Position失效了，跟ViewType对不齐)，就会从一级缓存里面移除这个ViewHolder，从添加到mCacheViews里面  
   3) 当调用removeAnimatingView方法时，如果当前ViewHolder被标记为remove,会调用recycleViewHolderInternal方法来回收对应的ViewHolder。调用removeAnimatingView方法的时机表示当前的ItemAnimator已经做完了。  

3. 回收到mHiddenViews。  
   个ViewHolder回收到mHiddenView数组里面的条件比较简单，如果当前操作支持动画，就会调用到RecyclerView的addAnimatingView方法，在这个方法里面会将做动画的那个View添加到mHiddenView数组里面去。通常就是动画期间可以会进行复用，因为mHiddenViews只在动画期间才会有元素。  

4. 回收到RecyclerViewPool。  
   RecyclerViewPool跟mCacheViews,都是通过recycleViewHolderInternal方法来进行回收，所以情景与mCacheViews差不多，只不过当不满足放入mCacheViews时，才会放入到RecyclerViewPool里面去。  

推荐参考：https://juejin.cn/post/6958962329220284453

**按照具体动作看内存作用**
列表项有4项，分别展示1、2、3、4四个数字。
*1). 更改数据4变为5，notifyItemChange发生了什么？*  
4、2、1倒叙放进attachedScrap里，3放进changedScrap里。然后create和bind一个新的vh，作为5的容器。然后1、2、5、4的layout顺序，将vh添加到视图中。验证了发生变化的vh会添加到changedScrap里。但是有两个问题没搞懂，一个是为什么放到changedScrap里的3数据已经变成了5，另外是所有itemChange都会create吗？  
*2). 移除3，notifyItemRemoved发生了什么？*  
4、3、2、1倒叙放进attachedScrap里，然后1、2、4重新添加到布局里，3直接删除。

列表项有4项，分别展示1、2、3、4四个数字。
*3). 列表共有10条数据，铺满用7条。滑动过程，缓存的变化？*
向上滑动，第1个vh滑出屏幕，放入cachedViews；第8条进入屏幕。cachedViews默认大小是2，所以当第2个vh滑出时，也放进去；第9条进入屏幕。此时向下滑，会复用cachedViews里的vh，取出第2条；同时第9条滑出屏幕，放入cachedView。  
当cachedView空间不足（=2），则会利用mRecyclerPool。mRecyclerPool会按照itemType存储vh。作用和cachedViews相似，只不过需要重新bindData。  
因此，总而言之，cachedViews和mRecyclerPool是用于滑动期间复用vh的。  

参考：https://mp.weixin.qq.com/s/SqjGeGW2c-BhmO5kW7kSrA

