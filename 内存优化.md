## 应用内存结构简析
Linux的进程不是直接操作物理内存，而是操作虚拟内存，虚拟内存由进程独享。  
虚拟内存的大小比物理内存要大很多，32位系统下是4G，64位下是256TB。物理内存就是手机上显示的实际内存，比如8G。  
虚拟内存分为应用程序数据和操作系统数据（内核空间）。比如4G的虚拟内存，用户空间占3G，内核空间占1G。  
**显然，虚拟内存的大小并不是可使用的就是这么大，而是我们申请内存的时候，地址是从这个范围内取，但是真正映射到物理内存是系统帮忙映射的。就是为了避免不同进程显示的进行物理内存的读写，相互影响。**  
## 内存指标获取
1. adb方式：
   adb shell
   dumpsys meminfo 进程名/pid
2. 线上运行时：

   ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
   ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
    
    或者

   Debug.MemoryInfo()
## 内存指标解读
PSS（ Proportional Set Size ）：实际使用的物理内存，会按比例分配共享的内存。比如一个应用有两个进程都用到了 Chrome 的 V8 引擎，那么每个进程会承担 50% 的 V8 这个 so 库的内存占用。PSS 是我们使用最频繁的一个指标，App 线上的内存数据统计一般都取这个指标。  
RSS（ Resident Set Size ）：PSS 中的共享库会按比例分担，但是 RSS 不会，它会完全算进当前进程，所以把所有进程的 RSS 加总后得出来的内存会比实际高。按比例计算内存占用会有一定的消耗，因此当想要高性能的获取内存数据时便可以使用 RSS，Android 的 LowMemoryKiller 机制就是根据每个进程的 RSS 来计算进程优先级的。  
Private Clean / Private Dirty：当我们执行 dump meminfo 时会看到这个指标，Private 内存是只被当前进程独占的物理内存。独占的意思是即使释放之后也无法被其他进程使用，只有当这个进程销毁后其他进程才能使用。Clean 表示该对应的物理内存已经释放了，Dirty 表示对应的物理内存还在使用。  
Swap Pss Dirty：这个指标和上面的 Private 指标刚好相反，Swap 的内存被释放后，其他进程也可以继续使用，所以我们在 meminfo 中只看得到 Swap Pss Dirty，而看不到Swap Pss Clean，因为 Swap Pss Clean 是没有意义的。  
Heap Alloc：通过 Malloc、mmap 等函数实际申请的虚拟内存，包括 Naitve 和虚拟机申请的内存。  
Heap Free：空闲的虚拟内存。  

**平时需要关注的，是Java Heap和Native Heap的PSS数据，可以通过Debug.MemoryInfo()获取到。**  

以小米11为例，获取的数值为256mb，还可以在manifest里设置 android:largeHeap="true" ，设置完数据会达到512mb。  
运行时获取可用堆内存上限：  
    标准数据（固定配置）：ActivityManager.getMemoryClass() 小米11固定返回256mb。（未开启LargeHeap: ActivityManager.getLargeMemoryClass() 小米11固定返回512mb）  
    真实数据：Runtime.getRuntime().maxMemory()。依据是否开启LargeHeap，返回约等于256或512.

## 物理内存：Java堆优化
两个前提：  
1. Java堆的空间有限，最多256(512)mb。
2. 只有切断Java对象和GC root的关联后，虚拟机GC才会回收该对象。

三个方向：
1. 减少加载进程 Java 堆的数据。
2. 及时清理加载进 Java 堆的数据。
3. 增加 Java 堆空间可用大小。

### 减少缓存大小
对于List、Map等缓存用的数据结构，考虑设置缓存上限，另外考虑设置阈值，以Java Heap为标准，及时清理数据。

### 按需加载数据
谨慎进行预加载，使用的时候再加载数据。

### 转移数据
java堆的数据转移到Native中，比如android 8 之后的Bitmap；将当前进程中 Java 堆的数据转移到其他进程中，比如小程序、Flutter、RN、WebView 等容器承载的业务。

### 及时清理加载进Java堆的数据
业务结束或者内存不足的时候及时切断对象和GC root的联系。可以定期用Runtime获取内存使用情况，判断是否要进行清除工作。

### 增加Java堆的大小
黑科技，由于堆的两个分区MainSpace 和 LargeObjectSpace（用于存放大对象）共用一个判断oom的标志位num_bytes_allocated_ ，当二者累加超过512的时候，就会oom。所以可以通过native hook，让LargeObjectSpace不算在这个标志位里，这样就有了512+512共1G的Java堆。  

## native内存优化
### native堆的组成
1. so 库中通过 malloc 、calloc 、realloc 、mmap 等函数申请函数的内存。
2. Bitmap 的占用，从 Android 8 开始，Bitmap 的内存都是算在 Native 上的。

### 如何定位？
1. 通过 Native Hook 技术，hook 住 so 库中申请内存和释放内存的函数。在此基础上，我们就可以统计出一个 so 库一共申请了多少内存，释放了多少内存。并且当 so 库申请了超大的内存时，还能获取 Native 的堆栈，便于定位异常函数。  
2. 对于 so 库申请了超大内存的的情况，我们需要获取 Native 的堆栈用于定位问题。
3. 直接获取的 Native 堆栈是一个个 16 进制地址的堆栈，无法看出有效信息，所以还需要根据 16 进制的地址堆栈还原出 so 名以及具体的函数和位置。

### so库优化、Native hook(todo)

### Bitmap内存优化
### Bitmap大小
分辨率*单个像素占用字节数。  
通用优化手段：
1. 改变图片格式，ARGB8888->RGB565
2. 缩小尺寸。（因为实际上用不到原图这么大）
3. 复用：三级缓存。内存、磁盘、网络。

### 定位异常Bitmap
字节码操作，通过字节码hook Bitmap的创建。
1. 通过ASM 插桩，辨析自定义gradle插件。ASM是一款字节码操作技术，可在 .class 文件编译成 dex 文件前，修改.class文件(略)
2. 通过Lancet框架实现hook.该框架还是用的ASM技术。

### Bitmap优化治理
通过字节码hook，在创建的过程中，根据需要调整Bitmap的尺寸、格式。等。

## 虚拟内存优化
### 线程治理
### 线程创建
Thread在创建的时候，会占用1M的虚拟栈空间。（可以看native层实现）
### 减少线程数量
1. 在应用中使用统一的线程池；
2. 将应用中的野线程及野线程池进行收敛。

### Android5-7，禁用拷贝回收算法，释放年轻代的另一个512mb。（略，因为64位机不需要，虚拟空间足够）



## 内存治理思路
所申请内存 > 可分配内存 - 已分配内存  
1. 所申请内存：压缩，复用。
2. 可分配内存：扩容。
3. 已分配内存：回收，压缩，复用。

### String字符串优化
### +号拼接的方式，在jdk1.5以上会被优化为StringBuilder.append.

### 大文件String存储？
1. 按需读取。
2. 分段读取。
3. 结构化存储。


### Bitmap治理
